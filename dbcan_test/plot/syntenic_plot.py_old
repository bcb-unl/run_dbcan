import matplotlib.pyplot as plt
from matplotlib.path import Path
from matplotlib.patches import PathPatch, Polygon, Patch
from matplotlib.lines import Line2D
import warnings
import os
from parameter import SynPlotConfig

warnings.filterwarnings("ignore", category=UserWarning)

class SyntenicPlotConfig:
    def __init__(self, config: SynPlotConfig):
        self.config = config
        self.input_sub_out = SynPlotConfig.input_sub_out
        self.blastp = SynPlotConfig.blastp
        self.cgc = SynPlotConfig.cgc
        self.db_dir = SynPlotConfig.db_dir
        self.output_dir = SynPlotConfig.output_dir

class BlastpHit:
    def __init__(self, lines):
        self.qseqid = lines[0]
        self.sseqid = lines[1]
        self.pident = lines[2]
        self.length = int(lines[3])
        self.mismatch = int(lines[4])
        self.gapopen = int(lines[5])
        self.qstart = int(lines[6])
        self.qend = int(lines[7])
        self.sstart = int(lines[8])
        self.send = int(lines[9])
        self.evalue = float(lines[10])
        self.bitscore = float(lines[11])
        if len(lines) >= 13:
            self.qlen = int(lines[12])
        if len(lines) >= 14:
            self.slen = int(lines[13])

    def __repr__(self):
        return "\t".join([str(self.__dict__[attr]) for attr in self.__dict__])

    def __eq__(self, other):
        return self.evalue == other.evalue and self.bitscore == other.bitscore and self.pident == other.pident

    def __le__(self, other):
        if self.evalue > other.evalue:
            return True
        elif self.evalue == other.evalue:
            if self.bitscore < other.bitscore:
                return True
            elif self.bitscore == other.bitscore:
                return self.pident < other.pident
        return False

def identity_map(seqsim):
    if 80 <= seqsim <= 100:
        return "red"
    elif 60 <= seqsim <= 80:
        return "blue"
    elif 40 <= seqsim <= 60:
        return "green"
    elif 20 <= seqsim <= 40:
        return "cyan"
    else:
        return "gray"

def get_position(starts, ends, strands, maxbp, yshift=0, up=1):
    width = 1000
    height = 160
    poly_height = 5
    triangle_length = 4
    plot_start_x, plot_start_y = [0, height / 2 - poly_height - yshift]
    polygens = []
    shift_pos = starts[0]
    starts = [start - shift_pos for start in starts]
    ends = [end - shift_pos for end in ends]
    pix_each_bp = width / maxbp

    blocks = []
    lines = []
    for i in range(len(starts)):
        if strands[i] == "+":
            positions_str = f"{starts[i] * pix_each_bp} {plot_start_y} {ends[i] * pix_each_bp - triangle_length} {plot_start_y} "
            if up == 1:
                blocks.append(positions_str)
            positions_str += f"{ends[i] * pix_each_bp} {plot_start_y + poly_height} {ends[i] * pix_each_bp - triangle_length} {plot_start_y + 2 * poly_height} {starts[i] * pix_each_bp} {plot_start_y + 2 * poly_height}"
            if up == 2:
                blocks.append(positions_str)
        elif strands[i] == "-":
            positions_str = f"{starts[i] * pix_each_bp} {plot_start_y + poly_height} {starts[i] * pix_each_bp + triangle_length} {plot_start_y} {ends[i] * pix_each_bp} {plot_start_y}"
            if up == 1:
                blocks.append(positions_str)
            positions_str += f"{ends[i] * pix_each_bp} {plot_start_y + 2 * poly_height} {starts[i] * pix_each_bp + triangle_length} {plot_start_y + 2 * poly_height}"
            if up == 2:
                blocks.append(positions_str)
        polygens.append(positions_str)
        if i < len(starts) - 1:
            positions_str = f"{ends[i] * pix_each_bp} {plot_start_y + poly_height} {starts[i + 1] * pix_each_bp} {plot_start_y + poly_height}"
            lines.append(positions_str)

    scale_number = 10
    each_scale_bp = maxbp / scale_number
    each_scale_pix = each_scale_bp * pix_each_bp

    plot_start_y -= 30
    scale_positions = [f"0 {plot_start_y + 3 * poly_height} {10 * each_scale_pix} {plot_start_y + 3 * poly_height}"]
    plot_start_y -= 1
    scale_positions_texts = []
    scale_text = []
    for i in range(scale_number + 1):
        positions_str = f"{i * each_scale_pix} {plot_start_y + 3 * poly_height} {i * each_scale_pix} {plot_start_y + 3 * poly_height + 0.6 * poly_height}"
        scale_positions.append(positions_str)
        positions_str = f"{i * each_scale_pix} {plot_start_y + 3 * poly_height + 0.6 * poly_height}"
        scale_positions_texts.append(positions_str)
        scale_text.append(str(int(each_scale_bp * i) + shift_pos))

    return polygens, blocks, lines, scale_positions, scale_text

def plot_polygon_homologous(polygens1, polygens2, types1, types2, ax):
    colors_map = {"CAZyme": "#FF0000", "null": "#808080", "Other": "#000000", "TC": "#9400D3", "STP": "#0000FF", "TF": "#1E90FF"}
    default_color = "#000000"
    for j in range(len(polygens1)):
        polygen = polygens1[j].split()
        points = [[float(polygen[2 * i]), float(polygen[2 * i + 1])] for i in range(int(len(polygen) / 2))]
        color = colors_map.get(types1[j], default_color)
        ax.add_patch(Polygon(points, color=color, alpha=0.5, lw=0))

    for j in range(len(polygens2)):
        polygen = polygens2[j].split()
        points = [[float(polygen[2 * i]), float(polygen[2 * i + 1])] for i in range(int(len(polygen) / 2))]
        color = colors_map.get(types2[j], default_color)
        ax.add_patch(Polygon(points, color=color, alpha=0.5, lw=0))

def decode_block(block):
    order1, order2, sim = block.split("-")
    return int(order1), int(order2), float(sim)

def points2(coord):
    x1, y1, x2, y2 = coord.split()
    return float(x1), float(y1), float(x2), float(y2)

def shade_curve(x11, x12, y11, y12, x21, x22, y21, y22, xmid, ymid, color):
    pathdata = [
        (Path.MOVETO, (x11, y11)),
        (Path.CURVE4, (x11, ymid)),
        (Path.CURVE4, (x21, ymid)),
        (Path.CURVE4, (x21, y21)),
        (Path.LINETO, (x22, y22)),
        (Path.CURVE4, (x22, ymid)),
        (Path.CURVE4, (x12, ymid)),
        (Path.CURVE4, (x12, y12)),
        (Path.CLOSEPOLY, (x11, y11))
    ]
    codes, verts = zip(*pathdata)
    path = Path(verts, codes)
    return PathPatch(path, color=color, alpha=0.2, lw=0)

def plot_syntenic_block(blocks, blocks1_coor, blocks2_coor, ax):
    for block in blocks:
        order1, order2, sim = decode_block(block)
        coord1 = blocks1_coor[order1]
        coord2 = blocks2_coor[order2]
        x11, y11, x12, y12 = points2(coord1)
        x21, y21, x22, y22 = points2(coord2)
        color = identity_map(sim)
        xmid = (x11 + x22 + x21 + x22) / 4
        ymid = (y11 + y22) / 2
        pp = shade_curve(x11, x12, y11, y12, x21, x22, y21, y22, xmid, ymid, color)
        ax.add_patch(pp)

def plot_genome_line(lines_coor1, lines_coor2, ax):
    for line in lines_coor1:
        x1, y1, x2, y2 = points2(line)
        ax.add_patch(Polygon([(x1, y1), (x2, y2)], color="gray", lw=2))
    for line in lines_coor2:
        x1, y1, x2, y2 = points2(line)
        ax.add_patch(Polygon([(x1, y1), (x2, y2)], color="gray", lw=2))

def syntenic_plot(starts, starts1, ends, ends1, strands, strands1, types, types1, blocks, cgcid, pulid, config):
    custom_lines = [
        Line2D([0], [0], color="red", lw=4, alpha=0.5),
        Line2D([0], [0], color="blue", lw=4, alpha=0.5),
        Line2D([0], [0], color="green", lw=4, alpha=0.5),
        Line2D([0], [0], color="cyan", lw=4, alpha=0.5),
        Line2D([0], [0], color="gray", lw=4, alpha=0.5)
    ]

    labelcolor = ["red", "blue", "green", "cyan", "gray"]
    labels = ["80-100", "60-80", "40-60", "20-40", "0-20"]

    genecustom_lines = [
        Patch(color="#FF0000", alpha=0.5),
        Patch(color="#808080", alpha=0.5),
        Patch(color="#9400D3", alpha=0.5),
        Patch(color="#0000FF", alpha=0.5),
        Patch(color="#1E90FF", alpha=0.5)
    ]

    genelabelcolor = ["#FF0000", "#808080", "#9400D3", "#0000FF", "#1E90FF", "#000000"]
    geneslabels = ["CAZyme", "Null", "TC", "STP", "TF", "Other"]

    px = 1 / plt.rcParams['figure.dpi']
    width = 1600
    height = 320 * 2

    fig = plt.figure(figsize=(width * px, height * px * 2 / 4))
    ax = fig.add_subplot(111)

    maxbp = max([max(ends) - min(starts), max(ends1) - min(starts1)])

    polygens, blocks_coor, lines_coor, _, _ = get_position(starts, ends, strands, maxbp, yshift=0, up=1)
    polygens1, blocks1_coor, lines_coor1, _, _ = get_position(starts1, ends1, strands1, maxbp, yshift=40, up=2)

    plot_polygon_homologous(polygens, polygens1, types, types1, ax)
    plot_syntenic_block(blocks, blocks_coor, blocks1_coor, ax)
    plot_genome_line(lines_coor, lines_coor1, ax)

    legend1 = plt.legend(custom_lines, labels, frameon=False, labelcolor=labelcolor, loc='upper left', title="Identity", title_fontsize="x-large")
    ax.add_artist(legend1)

    legend2 = plt.legend(genecustom_lines, geneslabels, frameon=False, labelcolor=genelabelcolor, loc='lower left', title="Gene", title_fontsize="x-large")
    ax.add_artist(legend2)

    plt.text(500, 90, cgcid, fontsize=30, horizontalalignment='center')
    plt.text(500, 0, pulid, fontsize=30, horizontalalignment='center')
    plt.ylim(0, 100)
    plt.xlim(-100, 1100)
    plt.axis('off')
    ax.plot()
    plt.tight_layout(pad=0.01)
    cgcid = cgcid.replace("|", "_")
    plt.savefig(f"{config['output_dir']}/synteny_pdf/{cgcid}-syntenic.pdf")
    plt.close()

def read_blast_result_cgc(filename):
    querydict = {}
    with open(filename) as file:
        for line in file:
            lines = line.split()
            queryids = lines[0].split("|")
            queryid = queryids[0] + "|" + queryids[1]
            hitpulid = lines[1].split(":")[1]
            querydict.setdefault(queryid + ":" + hitpulid, []).append(BlastpHit(lines))
    return querydict

def syntenic_plot_allpairs(self, config):
    self.config = config
    config = SyntenicPlotConfig(self.config)
    cgcpul_blastp = read_blast_result_cgc(self.blastp)
    cgc_proteinid2gene, cgcid2gene, cgcid2geneid = read_UHGG_CGC_stanrdard_out(self.cgc)
    PULid_proteinid2gene, PULid2gene, PULid2geneid = read_PUL_cgcgff(self.config)
    pdf_directory = os.path.join(self.output_dir, "synteny_pdf")
    os.makedirs(pdf_directory, exist_ok=True)

    with open(self.input_sub_out) as file:
        for line in file.readlines()[1:]:
            lines = line.rstrip().split("\t")
            cgc = lines[0]
            pul = lines[1]
            if not pul:
                continue

            cgcpul = cgc + ":" + pul
            bed_cgc = cgcid2gene[cgc]
            bed_pul = PULid2gene[pul]

            starts1, ends1, strands1, types1 = get_parameters_for_plot(bed_cgc)
            starts2, ends2, strands2, types2 = get_parameters_for_plot(bed_pul)
            genes1 = cgcid2geneid[cgc]
            genes2 = PULid2geneid[pul]

            blocks = []
            for record in cgcpul_blastp[cgcpul]:
                query = record.qseqid
                hit = record.sseqid
                cgc_proteinid = query.split("|")[2]
                pul_proteinid = hit.split(":")[3]
                if not pul_proteinid:
                    pul_proteinid = hit.split(":")[2]
                try:
                    index1 = genes1.index(cgc_proteinid)
                    index2 = genes2.index(pul_proteinid)
                    blocks.append(f"{index1}-{index2}-{record.pident}")
                except:
                    continue
            syntenic_plot(starts1, starts2, ends1, ends2, strands1, strands2, types1, types2, blocks, cgc, pul, config)

def get_parameters_for_plot(CGC_stanrdard_list):
    starts = [gene.Gene_Start for gene in CGC_stanrdard_list]
    ends = [gene.Gene_END for gene in CGC_stanrdard_list]
    strands = [gene.Strand for gene in CGC_stanrdard_list]
    types = [gene.Gene_Type for gene in CGC_stanrdard_list]
    return starts, ends, strands, types

def attribution(desc, mark="DB"):
    descs = desc.split(";")
    for des in descs:
        if des.startswith(mark):
            return des.split("=")[-1]
    return "Other"

def trim_proteinid(proteinid):
    return proteinid.split(".")[0]

def read_PUL_cgcout(filename="PUL.out"):
    geneid2gene = {}
    with open(filename) as file:
        for line in file:
            if line.startswith("++++"):
                continue
            lines = line.rstrip("\n").split("\t")
            proteinid = trim_proteinid(lines[8])
            newline = [lines[4] + lines[0], lines[1], lines[5], proteinid, lines[5], lines[6], lines[9], attribution(lines[-1])]
            geneid2gene[proteinid] = CGC_stanrdard(newline)
    return geneid2gene

def read_cgcgff(filename, geneid2gene):
    if not os.path.exists(filename):
        return None
    with open(filename) as file:
        for line in file:
            lines = line.rstrip("\n").split("\t")
            proteinid = attribution(lines[-1], "ID")
            proteinid = trim_proteinid(proteinid)
            PULid = filename.split('.')[0].split("/")[-1]
            if lines[2] == "CDS":
                lines[2] = "other"
            newline = [PULid, lines[2], lines[0], proteinid, lines[3], lines[4], lines[6], attribution(lines[-1])]
            geneid2gene[PULid + ":" + proteinid] = CGC_stanrdard(newline)

def read_PUL_cgcgff(self):
    config = SyntenicPlotConfig(self.config)
    PULidgeneid2gene = {}
    dbCANPUL_data_folder = self.db_dir if self.db_dir.endswith("/") else self.db_dir + "/"
    if not dbCANPUL_data_folder.startswith("/"):
        dbCANPUL_data_folder = os.path.abspath(dbCANPUL_data_folder) + "/dbCAN-PUL/"
    else:
        dbCANPUL_data_folder += "/dbCAN-PUL/"
    folder = os.listdir(dbCANPUL_data_folder)
    for filename in folder:
        if filename.startswith("PUL") and filename.endswith(".out"):
            read_cgcgff(dbCANPUL_data_folder + filename + "/cgc.gff", PULidgeneid2gene)

    cgcid2gene = {}
    cgcid2geneid = {}
    for PULidgeneid in PULidgeneid2gene:
        gene = PULidgeneid2gene[PULidgeneid]
        cgcid2gene.setdefault(gene.CGCID, []).append(gene)
        cgcid2geneid.setdefault(gene.CGCID, []).append(gene.Protein_ID)

    return PULidgeneid2gene, cgcid2gene, cgcid2geneid

class CGC_stanrdard:
    def __init__(self, lines):
        self.CGCID = lines[0]
        self.Gene_Type = lines[1]
        self.Contig_ID = lines[2]
        self.Protein_ID = lines[3]
        self.Gene_Start = int(lines[4])
        self.Gene_END = int(lines[5])
        self.Strand = lines[6]
        self.Protein_Family = lines[7]

    def __repr__(self):
        return "\t".join([str(self.__dict__[attr]) for attr in self.__dict__])

def read_UHGG_CGC_stanrdard_out(filename):
    geneid2gene = {}
    cgcid2gene = {}
    cgcid2geneid = {}

    with open(filename) as file:
        for line in file:
            if line.startswith("CGC#"):
                continue
            lines = line.rstrip("\n").split("\t")
            lines[0] = lines[2] + "|" + lines[0]
            gene = CGC_stanrdard(lines)
            geneid2gene[gene.Protein_ID] = gene
            cgcid2gene.setdefault(gene.CGCID, []).append(gene)
            cgcid2geneid.setdefault(gene.CGCID, []).append(gene.Protein_ID)

    return geneid2gene, cgcid2gene, cgcid2geneid
